<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Top Down Survival Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; margin: 0 auto; background: #111; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const MAX_ENEMIES = 14;

    let keys = {};
    let animationId = null;
    let spawnIntervalId = null;
    let gameOver = false;

    const ENEMY_LABELS = [
      "Homework",
      "Sports Practice",
      "Mom on Suzy Day",
      "Dad Helping with Homework",
      "Tests",
      "Rainy Day",
      "Peer Pressure",
      "Being Chopped",
      "Walking Home",
      "Punished",
      "No Screen Time",
      "Feed the Pets",
      "Do the Dishes",
      "Kitty Litter"
    ];

    // Used to ensure no duplicate enemy labels appear at the same time.
    let remainingLabels = [];

    function isMomDad(label) {
      return label === "Mom on Suzy Day" || label === "Dad Helping with Homework";
    }

    // Scoreboard key (drawn on screen)
    const SCORE_KEY = [
      "500 = You've failed at Madison",
      "1000 = Like averaging a C in school",
      "1500 = Not bad!",
      "2000 = George Mason material",
      "2500 = Like 1500 in SATs",
      "3000 = Harvard here we come!"
    ];

    function currentScoreTier(score) {
      // Highest tier achieved so far
      if (score >= 3000) return "Harvard here we come!";
      if (score >= 2500) return "Like 1500 in SATs";
      if (score >= 2000) return "George Mason material";
      if (score >= 1500) return "Not bad!";
      if (score >= 1000) return "Like averaging a C in school";
      if (score >= 500)  return "You've failed at Madison";
      return "Survive longer to level up";
    }

    document.addEventListener("keydown", (e) => {
      keys[e.key] = true;
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();
      // Allow restart any time, but it only triggers if gameOver === true.
      if ((e.key === "r" || e.key === "R") && gameOver) resetGame();
    });

    document.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    let player, enemies, score;

    function resetGame() {
      player = { x: 390, y: 290, size: 14, speed: 4, label: "Shen Kid" };
      enemies = [];
      score = 0;
      gameOver = false;

      // Reset label pool so all 14 labels are available once per run
      remainingLabels = ENEMY_LABELS.slice();

      if (animationId !== null) cancelAnimationFrame(animationId);
      if (spawnIntervalId !== null) clearInterval(spawnIntervalId);

      spawnIntervalId = setInterval(spawnEnemy, 1000);
      gameLoop();
    }

    function spawnEnemy() {
      if (gameOver) return;
      if (enemies.length >= MAX_ENEMIES) return;
      if (remainingLabels.length === 0) return; // No labels left to keep enemies distinct

      const size = 12;
      const side = Math.floor(Math.random() * 4);
      let x, y;

      if (side === 0) { x = -size; y = Math.random() * canvas.height; }
      if (side === 1) { x = canvas.width + size; y = Math.random() * canvas.height; }
      if (side === 2) { x = Math.random() * canvas.width; y = -size; }
      if (side === 3) { x = Math.random() * canvas.width; y = canvas.height + size; }

      // Pick a unique label by removing it from the remaining pool
      const idx = Math.floor(Math.random() * remainingLabels.length);
      const label = remainingLabels.splice(idx, 1)[0];

      // Slower overall. Mom/Dad a bit faster than the others.
      const speed = isMomDad(label)
        ? (1.2 + Math.random() * 0.6)
        : (0.6 + Math.random() * 0.6);

      enemies.push({ x, y, size, speed, label });
    }

    function endGame() {
      gameOver = true;

      if (spawnIntervalId !== null) clearInterval(spawnIntervalId);
      spawnIntervalId = null;

      if (animationId !== null) cancelAnimationFrame(animationId);
      animationId = null;

      draw(true);
    }

    function update() {
      if (gameOver) return;

      if (keys["ArrowUp"] || keys["w"]) player.y -= player.speed;
      if (keys["ArrowDown"] || keys["s"]) player.y += player.speed;
      if (keys["ArrowLeft"] || keys["a"]) player.x -= player.speed;
      if (keys["ArrowRight"] || keys["d"]) player.x += player.speed;

      player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));

      for (const enemy of enemies) {
        const dx = (player.x + player.size / 2) - (enemy.x + enemy.size / 2);
        const dy = (player.y + player.size / 2) - (enemy.y + enemy.size / 2);
        const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;

        enemy.x += (dx / dist) * enemy.speed;
        enemy.y += (dy / dist) * enemy.speed;

        if (dist < (player.size * 0.75 + enemy.size * 0.75)) {
          endGame();
          return;
        }
      }

      score++;
    }

    function drawHud() {
      // Score and current tier
      ctx.fillStyle = "white";
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";

      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 26);

      ctx.font = "14px Arial";
      ctx.fillText("Status: " + currentScoreTier(score), 10, 46);

      // Always-visible restart hint
      ctx.font = "14px Arial";
      ctx.fillText("Press R to restart game", 10, 66);

      // Scoreboard key (right side)
      const panelX = 520;
      const panelY = 10;
      const lineH = 16;

      ctx.font = "12px Arial";
      ctx.fillText("Scoreboard Key:", panelX, panelY + 14);
      for (let i = 0; i < SCORE_KEY.length; i++) {
        ctx.fillText(SCORE_KEY[i], panelX, panelY + 14 + (i + 1) * lineH);
      }
    }

    function draw(showGameOver = false) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Player
      ctx.fillStyle = "lime";
      ctx.fillRect(player.x, player.y, player.size, player.size);

      // Player label
      ctx.fillStyle = "white";
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(player.label, player.x + player.size / 2, player.y - 3);

      // Enemies + labels
      for (const enemy of enemies) {
        ctx.fillStyle = "red";
        ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);

        ctx.fillStyle = "white";
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(enemy.label, enemy.x + enemy.size / 2, enemy.y + enemy.size + 2);
      }

      // HUD (score, tier, key, restart hint)
      drawHud();

      if (showGameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "white";
        ctx.textAlign = "center";

        ctx.font = "44px Arial";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 60);

        ctx.font = "24px Arial";
        ctx.fillText("Final Score: " + score, canvas.width / 2, canvas.height / 2 - 10);

        ctx.font = "18px Arial";
        ctx.fillText("Status: " + currentScoreTier(score), canvas.width / 2, canvas.height / 2 + 22);

        ctx.font = "20px Arial";
        ctx.fillText("Press R to Restart", canvas.width / 2, canvas.height / 2 + 58);
      }
    }

    function gameLoop() {
      update();
      draw(false);
      if (!gameOver) animationId = requestAnimationFrame(gameLoop);
    }

    resetGame();
  </script>
</body>
</html>